#include <stdint.h>
#include <event.h>
#include <lynx_dev.h>
#include <version.h>
#include <cfg_api_new.h>
#include <wla_api.h>
#include <omniconfig.h>
#include "at_cmd.h"
#include "at.h"
#include "at_cmd_func.h"
#include "user_config.h"

extern u32 urbase[];
extern at_funcationType at_fun[];
extern at_stateType  at_state;
extern unsigned char specialAtState;
extern uint8_t at_dataLine[];
extern unsigned char *pDataLine;
extern struct serial_buffer* ur1_rxbuf;
extern uint8_t elink_flag;
extern char omni_mac_str[16];



/*!-----------------------------------------------------------------------------
 * function: go_cli
 *
 *  \brief:    Go to CLI mode
 *  \operator: NULL execute
 *  \return:   check result
 +----------------------------------------------------------------------------*/
#if 0
extern int cmd_loop(void);
int at_go_cli(int argc, char *argv[], char *op[])			//cli
{
	if(strcmp(op,NUL))
		return at_ERR_OP;
	if(argc != 0)
		return at_ERR_PARM;

	/* continue to enter sleeping mode even go to CLI mode */
	ldev->wmac.ps_uart = 2;
	if(ldev->ur.chan == 3)//ldev->udev.cfg_len == 67
		EVENT_REGISTER((evt_func)cmd_loop, EVT_HOST_NUM);
	else
		EVENT_REGISTER((evt_func)cmd_loop, EVT_UART_RX_NUM);

	return at_ERR_CLI;
}

static void reboot(int sec)
{
  extern uint8_t watchdog_flag;
  watchdog_flag = 0;
	PMUREG(SLP_WDOG_TMR_CTRL) = SLP_WDOG_TMR_EN|(sec*32000); 
}
#endif



/*!-----------------------------------------------------------------------------
 * function: ur_config
 *
 *  \brief:    Set or query UART baud rate, data bits, parity, stop bits, flow control
 *  \operator: "="set, "=?"query the current setting
 *  \param 0:  baudrate id 0~12
 *  \param 1:  parity   0: no, 1: even, 2: odd
 *  \param 2:  stopbits 1,2
 *  \return:   check result
 +----------------------------------------------------------------------------*/

extern unsigned int br_tb[];

/**
  * @brief  Execution commad of AT.
  * @param  id: commad id number
  * @retval None
  */
void at_exeCmdNull(uint8_t id)
{
  at_backOk;
  return;
}


void at_exeCmdVersion(uint8_t id){
  at_backOkHead;
  if(!memcmp(at_fun[id].at_cmdName,"VER",3)){
    uart0_sendStr(sw_build_sdk);
  }else if(!memcmp(at_fun[id].at_cmdName,"FWSZ",4)){
    uart0_sendStr(FWSZE);
  }else{
    uart0_sendStr("%s %s,%s",LVER,__DATE__,__TIME__);
  }
  at_backTail;
  return;
}


void at_exeCmdRst(uint8_t id){
	config_submit();
  rf_config_submit();
	reboot(1);
	at_backOk;
	return;
}


void at_exeCmdReld(uint8_t id){
  config_erase();
#if (ERASE_ONCE == 0)
  rf_config_erase();
#endif
  reboot(1);
  at_backOkHead;
  uart0_sendStr("rebooting...");
  at_backTail;
  return;
}

void at_sockasendSet(void *arg){
  struct serial_buffer *pbuf = ur1_rxbuf;
  if(at_state == at_statIpTranout){
    at_state = at_statIpTraning;
  }

  if(!serial_buffer_empty(pbuf)){
  	at_ipDataSending();
  }
  return; 
}



void at_setupCmdEntm(uint8_t id)
{
  at_state = at_statIpTraning;
  specialAtState = false;
//  os_timer_disarm(&at_sendTimer[0]);
//  os_timer_setfn(&at_sendTimer[0], (os_timer_func_t *)at_sockasendSet, NULL);
  pDataLine = at_dataLine;
  if(id > 0){
    at_backOk;
  }
#if (MALLOC_NET_BUF_FIRST==0)
  net_rev_buf_free();
#endif
  return;
}



void at_setupCmdE(uint8_t id,char *pPara)
{
  if(!memcmp(pPara,"on",2)){
    g_atParam.echoFlag = true;
  }else if(!memcmp(pPara,"off",3)){
    g_atParam.echoFlag = false; 
  }else{
	at_backErrHead;
    uart0_sendStr("-4");
    at_backTail; 
    return;
  }
  at_backOk;
  return;
}

void at_exeCmdE(uint8_t id)
{
  if(g_atParam.echoFlag ==  true){
    g_atParam.echoFlag = false;
  }else{
    g_atParam.echoFlag = true;
  }
  at_backOk;
  return;
}

void at_exeCmdBoot(uint8_t id)
{
  boot_param bootInfo;
  flash_erase(CFG_FLASH_BOOTINFO_START,CFG_FLASH_MEM_LENGTH);
  bootInfo.boot = CFG_MAGIC;
  flash_write(CFG_FLASH_BOOTINFO_START, (unsigned int)&bootInfo, sizeof(boot_param));
  at_backOk;
  reboot(1);
}


static void omniconfig_done(char *ssid, char *key, int mode,int error)
{
  /* check omnicfg time cost*/
  unsigned char *mac;  
  network_info stacfg;
  if (OMNI_RET_SUCCESS == error) {
    
    serial_printf("WiFi SSID : %s\n", ssid);
    serial_printf("WiFi PWD  : %s\n", key);
    /*OMNICFG modified str*/
    memset(omni_mac_str, 0x0, sizeof(omni_mac_str));
    mac = wlan_get_myaddr(STATION);
    sprintf(omni_mac_str, "%02x%02x%02x%02x%02x%02x",
        mac[0], mac[1], mac[2],
        mac[3], mac[4], mac[5]);
    
    /* Initialize wlan parameteres */
    memset(&stacfg, 0x0, sizeof(stacfg));
    memcpy(stacfg.wifi_ssid, ssid, sizeof(stacfg.wifi_ssid)); /* wlan ssid string */
    memcpy(stacfg.wifi_key, key, sizeof(stacfg.wifi_key));    /* wlan key string or hex data */
    
    stacfg.wifi_mode = STATION;             /* wlan mode */
    stacfg.dhcp_mode = DHCP_CLIENT;           /* Fetch Ip address from DHCP server */
    
    stacfg.wifi_retry_interval = 100;         /* Retry interval after a failure connection */
    wlan_set_reconnect(g_rfParam.reconn);
    
    /* Connect Now! */
    /* calculate wifi scan/connect time*/
    serial_printf("\r\n============ START IOT_DEMO WIFI Connection : =========\r\n");
    wlan_start(&stacfg);
    
  }else{
    elink_flag = false;
  }
#if 0
   else if (OMNI_RET_TIMEOUT == error) {
    serial_printf("Result    : OMNICONFIG Timeout\n");
  } else if (OMNI_RET_ERR_SSID == error) {
    serial_printf("Result    : SSID Length is too long ! \n");
    serial_printf("          : SSID Length need be small than 32 .\n");
  } else if (OMNI_RET_ERR_PWD == error) {
    serial_printf("Result    : PWD Length is too long ! \n");
    serial_printf("          : PWD Length need be small than 64.\n");
  } else if (OMNI_RET_ERR_UNKNOW == error) {
    serial_printf("Result    : INTERNAL ERROR\n");
  }
#endif
}


void at_exeCmdSmatlk(uint8_t id)
{
  if(elink_flag == true){
    goto SMATLK;
    return;
  }
  elink_flag = true;
  //wlan_suspend();
  //PMUREG(PKG_MODE_CTRL) |= STATION_MODE;
  omnicfg_siso2_start(omniconfig_done,60*1000);
SMATLK:
  at_backOk;
  return;
}

void at_exeCmdHelp(uint8_t id){

  uart0_sendStr("AT+: NONE command,reply \"+ok\".\r\n");
  uart0_sendStr("AT+ASWD: Set/Query WiFi configuration code.\r\n");
  uart0_sendStr("AT+E: Echo ON/off, to turn on/off command line echo function.\r\n");
  uart0_sendStr("AT+ENTM: Goto Through Mode.\r\n");
  uart0_sendStr("AT+NETP: Set/Get the Net Protocol Parameters.\r\n");
  uart0_sendStr("AT+UART: Set/Get the UART Parameters.\r\n");
  uart0_sendStr("AT+UARTF: Enable/disable UART AutoFrame function.\r\n");
  uart0_sendStr("AT+UARTFT: Set/Get time of UART AutoFrame.\r\n");
  uart0_sendStr("AT+UARTFL: Set/Get frame length of UART AutoFrame.\r\n");
  uart0_sendStr("AT+UARTTE: Set/Query UART free-frame triggerf time between tow byte.\r\n");
  uart0_sendStr("AT+PING: General PING command.\r\n");
  uart0_sendStr("AT+WAP: Set/Get the AP Parameters.\r\n");
  uart0_sendStr("AT+WAKEY: Set/Get the Security Parameters of WiFi AP Mode.\r\n");
  uart0_sendStr("AT+WMODE: Set/Get the WiFi Operation Mode (AP or STA).\r\n");
  uart0_sendStr("AT+WSKEY: Set/Get the AP's Password of WiFi STA Mode.\r\n");
  uart0_sendStr("AT+WSSSID: Set/Get the AP's SSID of WiFi STA Mode.\r\n");
  uart0_sendStr("AT+WJAP: Set/Get the AP's SSID and Password of WiFi STA Mode.\r\n");
  uart0_sendStr("AT+WSLK: Get Link Status of the Module (Only for STA Mode).\r\n");
  uart0_sendStr("AT+WSLQ: Get Link Quality of the Module (Only for STA Mode)\r\n");
  uart0_sendStr("AT+WSCAN: Get The AP site Surver (only for STA Mode).\r\n");
  uart0_sendStr("AT+WEBU: Set/Get the Login Parameters of WEB page.\r\n");
  uart0_sendStr("AT+TCPLK: Get The state of TCP link.\r\n");
  uart0_sendStr("AT+TCPIO: Set/Get TCP time out.\r\n");
  uart0_sendStr("AT+TCPDIS: Connect/Dis-connect the TCP Client link.\r\n");
  uart0_sendStr("AT+RECV: Recv data from UART.\r\n");
  uart0_sendStr("AT+SEND: Send data to UART.\r\n");
  uart0_sendStr("AT+WANN: Set/Get The WAN setting if in STA mode.\r\n");
  uart0_sendStr("AT+LANN: Set/Get The LAN setting if inAP mode.\r\n");
  uart0_sendStr("AT+RELD: Reload the default setting and reboot.\r\n");
  uart0_sendStr("AT+RLDEN: Put on/off the GPIO12.\r\n");
  uart0_sendStr("AT+Z: Reset the Module.\r\n");
  uart0_sendStr("AT+MID: Get The Module ID.\r\n");
  uart0_sendStr("AT+VER: Get application version.\r\n");
  uart0_sendStr("AT+SHARE: Set/Get the output of passthrough mode share.\r\n");
  uart0_sendStr("AT+CLIENTS: Get access to the AP nums\r\n");
  uart0_sendStr("AT+H: Help.\r\n");
  at_backOk;
  return;
}


