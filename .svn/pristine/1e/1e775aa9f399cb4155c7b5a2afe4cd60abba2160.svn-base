#include <stdint.h>
#include <event.h>
#include <lynx_dev.h>
#include <version.h>
#include <cfg_api_new.h>
#include "at_cmd.h"
#include "at.h"
#include "at_cmd_func.h"
#include "user_config.h"
extern u32 urbase[];
extern at_funcationType at_fun[];
extern at_stateType  at_state;
extern unsigned char specialAtState;
extern uint8_t at_dataLine[];
extern unsigned char *pDataLine;
extern struct serial_buffer* ur1_rxbuf;




/*!-----------------------------------------------------------------------------
 * function: go_cli
 *
 *  \brief:    Go to CLI mode
 *  \operator: NULL execute
 *  \return:   check result
 +----------------------------------------------------------------------------*/
#if 0
extern int cmd_loop(void);
int at_go_cli(int argc, char *argv[], char *op[])			//cli
{
	if(strcmp(op,NUL))
		return at_ERR_OP;
	if(argc != 0)
		return at_ERR_PARM;

	/* continue to enter sleeping mode even go to CLI mode */
	ldev->wmac.ps_uart = 2;
	if(ldev->ur.chan == 3)//ldev->udev.cfg_len == 67
		EVENT_REGISTER((evt_func)cmd_loop, EVT_HOST_NUM);
	else
		EVENT_REGISTER((evt_func)cmd_loop, EVT_UART_RX_NUM);

	return at_ERR_CLI;
}
#endif
static void reboot(int sec)
{
	PMUREG(SLP_WDOG_TMR_CTRL) = SLP_WDOG_TMR_EN|(sec*32000); 
}



/*!-----------------------------------------------------------------------------
 * function: ur_config
 *
 *  \brief:    Set or query UART baud rate, data bits, parity, stop bits, flow control
 *  \operator: "="set, "=?"query the current setting
 *  \param 0:  baudrate id 0~12
 *  \param 1:  parity   0: no, 1: even, 2: odd
 *  \param 2:  stopbits 1,2
 *  \return:   check result
 +----------------------------------------------------------------------------*/

extern unsigned int br_tb[];

/**
  * @brief  Execution commad of AT.
  * @param  id: commad id number
  * @retval None
  */
void at_exeCmdNull(uint8_t id)
{
  at_backOk;
  return;
}


void at_exeCmdVersion(uint8_t id){
  at_backOkHead;
  if(!memcmp(at_fun[id].at_cmdName,"VER",3)){
    uart0_sendStr(sw_build_sdk);
  }else if(!memcmp(at_fun[id].at_cmdName,"FWSZ",4)){
    uart0_sendStr(FWSZE);
  }else{
    uart0_sendStr("%s %s,%s",LVER,__DATE__,__TIME__);
  }
  at_backTail;
  return;
}


void at_exeCmdRst(uint8_t id){
	config_submit();
	reboot(1);
	at_backOk;
	return;
}


void at_exeCmdReld(uint8_t id){
  config_erase();
  reboot(1);
  at_backOkHead;
  uart0_sendStr("rebooting...");
  at_backTail;
  return;
}

void at_sockasendSet(void *arg){
  struct serial_buffer *pbuf = ur1_rxbuf;
  if(at_state == at_statIpTranout){
    at_state = at_statIpTraning;
  }

  if(!serial_buffer_empty(pbuf)){
  	at_ipDataSending();
  }
  return; 
}



void at_setupCmdEntm(uint8_t id)
{
  at_state = at_statIpTraning;
  specialAtState = false;
//  os_timer_disarm(&at_sendTimer[0]);
//  os_timer_setfn(&at_sendTimer[0], (os_timer_func_t *)at_sockasendSet, NULL);
  pDataLine = at_dataLine;
  if(id > 0){
    at_backOk;
  }
#if (MALLOC_NET_BUF_FIRST==0)
  net_rev_buf_free();
#endif
  return;
}



void at_setupCmdE(uint8_t id,char *pPara)
{
  if(!memcmp(pPara,"on",2)){
    g_atParam.echoFlag = true;
  }else if(!memcmp(pPara,"off",3)){
    g_atParam.echoFlag = false; 
  }else{
	at_backErrHead;
    uart0_sendStr("-4");
    at_backTail; 
    return;
  }
  at_backOk;
  return;
}

void at_exeCmdE(uint8_t id)
{
  if(g_atParam.echoFlag ==  true){
    g_atParam.echoFlag = false;
  }else{
    g_atParam.echoFlag = true;
  }
  at_backOk;
  return;
}


void at_exeCmdHelp(uint8_t id){

  uart0_sendStr("AT+: NONE command,reply \"+ok\".\r\n");
  uart0_sendStr("AT+ASWD: Set/Query WiFi configuration code.\r\n");
  uart0_sendStr("AT+E: Echo ON/off, to turn on/off command line echo function.\r\n");
  uart0_sendStr("AT+ENTM: Goto Through Mode.\r\n");
  uart0_sendStr("AT+NETP: Set/Get the Net Protocol Parameters.\r\n");
  uart0_sendStr("AT+UART: Set/Get the UART Parameters.\r\n");
  uart0_sendStr("AT+UARTF: Enable/disable UART AutoFrame function.\r\n");
  uart0_sendStr("AT+UARTFT: Set/Get time of UART AutoFrame.\r\n");
  uart0_sendStr("AT+UARTFL: Set/Get frame length of UART AutoFrame.\r\n");
  uart0_sendStr("AT+UARTTE: Set/Query UART free-frame triggerf time between tow byte.\r\n");
  uart0_sendStr("AT+PING: General PING command.\r\n");
  uart0_sendStr("AT+WAP: Set/Get the AP Parameters.\r\n");
  uart0_sendStr("AT+WAKEY: Set/Get the Security Parameters of WiFi AP Mode.\r\n");
  uart0_sendStr("AT+WMODE: Set/Get the WiFi Operation Mode (AP or STA).\r\n");
  uart0_sendStr("AT+WSKEY: Set/Get the AP's Password of WiFi STA Mode.\r\n");
  uart0_sendStr("AT+WSSSID: Set/Get the AP's SSID of WiFi STA Mode.\r\n");
  uart0_sendStr("AT+WJAP: Set/Get the AP's SSID and Password of WiFi STA Mode.\r\n");
  uart0_sendStr("AT+WSLK: Get Link Status of the Module (Only for STA Mode).\r\n");
  uart0_sendStr("AT+WSLQ: Get Link Quality of the Module (Only for STA Mode)\r\n");
  uart0_sendStr("AT+WSCAN: Get The AP site Surver (only for STA Mode).\r\n");
  uart0_sendStr("AT+WEBU: Set/Get the Login Parameters of WEB page.\r\n");
  uart0_sendStr("AT+TCPLK: Get The state of TCP link.\r\n");
  uart0_sendStr("AT+TCPIO: Set/Get TCP time out.\r\n");
  uart0_sendStr("AT+TCPDIS: Connect/Dis-connect the TCP Client link.\r\n");
  uart0_sendStr("AT+RECV: Recv data from UART.\r\n");
  uart0_sendStr("AT+SEND: Send data to UART.\r\n");
  uart0_sendStr("AT+WANN: Set/Get The WAN setting if in STA mode.\r\n");
  uart0_sendStr("AT+LANN: Set/Get The LAN setting if inAP mode.\r\n");
  uart0_sendStr("AT+RELD: Reload the default setting and reboot.\r\n");
  uart0_sendStr("AT+RLDEN: Put on/off the GPIO12.\r\n");
  uart0_sendStr("AT+Z: Reset the Module.\r\n");
  uart0_sendStr("AT+MID: Get The Module ID.\r\n");
  uart0_sendStr("AT+VER: Get application version.\r\n");
  uart0_sendStr("AT+SHARE: Set/Get the output of passthrough mode share.\r\n");
  uart0_sendStr("AT+CLIENTS: Get access to the AP nums\r\n");
  uart0_sendStr("AT+H: Help.\r\n");
  at_backOk;
  return;
}


