#include <stdint.h>
#include <lynx_dev.h>
#include <event.h>
#include <common.h>
#include <serial.h>
#include <wla_api.h>
#include <cfg_api_new.h>
#include "at_cmd_s.h"
#include "user_config.h"
#include "at.h"

void wifi_mode_init(void){

  if (g_atParam.work_mode != OPMODE_STA && ap_start_func)
  {
    ap_start_func(g_atParam.ap_param.ssid,g_atParam.ap_param.key,g_atParam.ap_param.channel);
  }
  if (g_atParam.work_mode != OPMODE_AP && sta_start_func)
  {
    sta_start_func(g_atParam.sta_param.ssid,g_atParam.sta_param.key,g_atParam.sta_param.bssid);    
  }

  return;  
}


int8_t at_dataStrCpy(void *pDest, const void *pSrc, signed char maxLen)
{
//  assert(pDest!=NULL && pSrc!=NULL);

  char *pTempD = pDest;
  const char *pTempS = pSrc;
  int16_t  len;
  for(len=0; len<maxLen; len++)
  {
    if(*pTempS == ',' || *pTempS == '\r' || *pTempS == '\n')
    {
      *pTempD = '\0';
      break;
    }
    else
    {
      *pTempD++ = *pTempS++;
    }
  }
  if(len == maxLen)
  {
    return -1;
  }
  return len;
}


signed char qlz_dataStrCpy(void *pDest, const void *pSrc, signed char maxLen)
{
//  assert(pDest!=NULL && pSrc!=NULL);

  char *pTempD = pDest;
  const char *pTempS = pSrc;
  int16_t  len;
  for(len=0; len<maxLen; len++)
  {
    if(*pTempS == '\r' || *pTempS == '\n')
    {
      *pTempD = '\0';
      break;
    }
    else
    {
      *pTempD++ = *pTempS++;
    }
  }
  if(len == maxLen)
  {
    return -1;
  }
  return len;
}


/** @defgroup AT_BASECMD_Functions
  * @{
  */ 

/**
  * @brief  Query and localization one commad.
  * @param  cmdLen: received length of command
  * @param  pCmd: point to received command 
  * @retval the id of command
  *   @arg -1: failure
  */
static int16_t at_cmdSearch(signed char cmdLen, unsigned char *pCmd)
{
  int16_t i;

  if(cmdLen == 0)
  {
    return 0;
  }
  else if(cmdLen > 0)
  {
    for(i=1; i<at_cmdNum; i++)
    {
//      os_printf("%d len %d\r\n", cmdLen, at_fun[i].at_cmdLen);
      if(cmdLen == at_fun[i].at_cmdLen)
      {
//        os_printf("%s cmp %s\r\n", pCmd, at_fun[i].at_cmdName);
        if(memcmp(pCmd, at_fun[i].at_cmdName, cmdLen) == 0) //think add cmp len first
        {
          return i;
        }
      }
    }
  }
  return -1;
}

/**
  * @brief  Get the length of commad.
  * @param  pCmd: point to received command 
  * @retval the length of command
  *   @arg -1: failure
  */
static int8_t at_getCmdLen(unsigned char *pCmd)
{
  uint8_t n,i;

  n = 0;
  i = at_cmdLenMax;

  while(i--)
  {
    //汉枫模块，是以\n结尾，而不是以\r\n结尾
    if((*pCmd == '\r') || (*pCmd == '\n') || (*pCmd == '=') || (*pCmd == '?') || ((*pCmd >= '0')&&(*pCmd <= '9')))
    {
      return n;
    }
    else
    {
      pCmd++;
      n++;
    }
  }
  return -1;
}

/**
  * @brief  Distinguish commad and to execution.
  * @param  pAtRcvData: point to received (command) 
  * @retval None
  */
void at_cmdProcess(unsigned char *pAtRcvData)
{
  char tempStr[32];

  int16_t cmdId;
  int8_t cmdLen;
  int16_t i;

  cmdLen = at_getCmdLen(pAtRcvData);
  if(cmdLen != -1)
  {
    cmdId = at_cmdSearch(cmdLen, pAtRcvData);
  }
  else 
  {
    cmdId = -1;
  }
  if(cmdId != -1)
  {
//    os_printf("cmd id: %d\r\n", cmdId);
    pAtRcvData += cmdLen;
    //配置汉枫模块的功能
    if(*pAtRcvData == '\r' || *pAtRcvData == '\n')
    {
      if(at_fun[cmdId].at_exeCmd)
      {
        at_fun[cmdId].at_exeCmd(cmdId);
      }
      else
      {
        at_backErrHead;
        uart0_sendStr("-1");
        at_backTail;
      }
    }else if(*pAtRcvData == '=')
    {
      if(at_fun[cmdId].at_setupCmd)
      {
        //直接将处理的数据部分交给处理函数
        at_fun[cmdId].at_setupCmd(cmdId, pAtRcvData+1);
      }
      else
      {
        at_backErrHead;
        uart0_sendStr("-1");
        at_backTail;
      }      
    }
    else
    {
        at_backErrHead;
        uart0_sendStr("-3");
        at_backTail;
    }
  }
  else 
  {
    at_backErrHead;
    uart0_sendStr("-2");
    at_backTail;
  }
}



void mylinks_add_timeout_fun(void (*timer_func)(void *arg),unsigned int msec){
  del_timeout(timer_func,0);
  add_timeout(timer_func, 0, msec);
  return;
}

