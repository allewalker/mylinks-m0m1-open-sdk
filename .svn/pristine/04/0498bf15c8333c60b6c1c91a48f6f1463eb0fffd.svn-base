#include "at_cmd.h"
#include "at_cmd_func.h"
#include <event.h>
#include <lynx_dev.h>
#include <wla_api.h>
#include <net_api.h>
#include <socket_api.h>
#include "lwip/sockets.h"
#include <cfg_api_new.h>
#if defined(CONFIG_FREERTOS)
#include <FreeRTOS.h>
#include <task.h>
#endif
#include "at.h"
#include "user_config.h"


char trans_mode = 0;
int g_linkIdx = 0;
uint8_t sendingID = 0;
uint16_t at_sendLen = 0;
uint16_t at_revLen[2] = {0,0};
static char s_tsmodeEnable = 0;
static int s_dataLenth = -1;
extern at_funcationType at_fun[];
extern uint8_t specialAtState;
extern at_stateType  at_state;
extern uint8_t at_dataLine[];
extern uint8_t *pDataLine;
extern struct serial_buffer* ur1_rxbuf;

#ifdef CONFIG_LWIP

void at_exeCmdCupdate(uint8_t id){
	char *filename = NULL;
	char type;
	char *buffer = NULL;
	if(STA_LINK_GET_IP != get_slinkup()){
		at_backOkHead;
		uart0_sendStr("-5");
		at_backTail;
		return;		
	}
	buffer = (char *)malloc(128);
	if(NULL == buffer){
		goto UPERR;
	}
	if(!memcmp(at_fun[id].at_cmdName,"UPGRADE",7)){
		filename = "AT.img";
		type = 0;
	}else{
		filename = "minifs_rom.img";
		type = 1;
	}
	sprintf(buffer,"118.178.87.170/products/M0M100x/upgrade/AT/Mylinks/001/%s",filename);
	if(!Firmware_WIFIOTAByUrl(type,buffer,80)){
		free(buffer);
		at_backOk;
		return;
	}
	free(buffer);
UPERR:
	at_backErrHead;
	uart0_sendStr("-4");
	at_backTail;
	return;	
}

void at_setupCmdCupdate(uint8_t id,char *pPara){
	char type;
	if(STA_LINK_GET_IP != get_slinkup()){
		at_backOkHead;
		uart0_sendStr("-5");
		at_backTail;
		return;		
	}
	if(!memcmp(at_fun[id].at_cmdName,"UPGRADE",7)){
		type = 0;
	}else{
		type = 1;
	}
	if(!Firmware_WIFIOTAByUrl(type,pPara,80)){
		at_backOk;
		return;
	}
	at_backErrHead;
	uart0_sendStr("-4");
	at_backTail;
	return;	
}


uint8_t num_check(char *str)
{
	while(*str)
	{
		if(*str < '0' || *str > '9')
		{
			return 1;
		}
		str++;
	}
	return 0;
}


void at_sockarevCheck(void *arg){
	if(at_revLen[0])
	{
		net_read_save_to_buffer(0,at_revLen[0]);
		at_revLen[0] = 0;
	}
	specialAtState = true;
	at_state = at_statIdle;
	return;	
}

void at_sockbrevCheck(void *arg){
	if(at_revLen[1])
	{
		net_read_save_to_buffer(1,at_revLen[1]);
		at_revLen[1] = 0;
	}
	specialAtState = true;
	at_state = at_statIdle;
	return;	
}


void at_setupCmdCiprecv(uint8_t at_id, char *pPara)
{
	char len;
	short rev_len = 0;
	short timeout = 0;
	char temp[16];
	uint8_t id;
	len = at_dataStrCpy(temp,pPara,sizeof(temp)-1);
	if(!len ||len == -1)
	{
		at_backErrHead;
		uart0_sendStr("-4");
		return;		
	}
	rev_len = atoi(temp);
	if(num_check(temp) ||rev_len < 0 || rev_len > 1000)
	{
		at_backErrHead;
		uart0_sendStr("-4");
		at_backTail;
		return;
	}
	pPara += len + 1;
	len = qlz_dataStrCpy(temp,pPara,sizeof(temp)-1);

	if(!len || len == -1)
	{
		at_backErrHead;
		uart0_sendStr("-4");
		at_backTail;
		return;		
	}
	timeout = atoi(temp);
	if(num_check(temp) || timeout < 0 || timeout > 10)
	{
		at_backErrHead;
		uart0_sendStr("-4");
		at_backTail;
		return;			
	}
	id = (!memcmp(at_fun[at_id].at_cmdName,"RECV",4))?0:1;
	if(!timeout||check_buffer_len(id)){
		at_revLen[id] = 0;
		if(id == 0){
			del_timeout(at_sockarevCheck,0);
		}else{
			del_timeout(at_sockbrevCheck,0);
		}
		net_read_save_to_buffer(id,rev_len);
		return;
	}
	at_revLen[id] = rev_len;
	if(id == 0){
		mylinks_add_timeout_fun(at_sockarevCheck,timeout*1000);
	}else{
		mylinks_add_timeout_fun(at_sockbrevCheck,timeout*1000);
	}
	specialAtState = false;
	return;
}



void at_sockasendCheck(void *arg){
	struct serial_buffer *pbuf = ur1_rxbuf;
	if(!serial_buffer_empty(pbuf)){
		at_state = at_statIpSended;
		at_ipDataSending(at_dataLine);
	}
	return;	
}



void at_sockbsendCheck(void *arg){
	struct serial_buffer *pbuf = ur1_rxbuf;
	if(!serial_buffer_empty(pbuf)){
		at_state = at_statIpSended;
		at_ipDataSending(at_dataLine);		
	}
	return;	
}


void at_setupCmdCipsend(uint8_t at_id, char *pPara)
{
	signed char len;
	char temp[16];
	len = at_dataStrCpy(temp,pPara,sizeof(temp));

	at_sendLen = atoi(temp);
	if(len <=0 || num_check(temp) || at_sendLen > at_dataLenMax)
	{
		at_backErrHead;
		uart0_sendStr("-4");
		at_backTail;
		return;		
	}

	if(!memcmp(at_fun[at_id].at_cmdName,"SEND",4)){
		sendingID = 0;
		mylinks_add_timeout_fun(at_sockasendCheck,3000);
	}else{
		sendingID = 1;
		mylinks_add_timeout_fun(at_sockbsendCheck,3000);
	}
	at_state = at_statIpSending;
	pDataLine = at_dataLine;
	specialAtState = false;
	uart0_sendStr(">");
	return;
}



/*!-----------------------------------------------------------------------------
 * function: at_net_dhcps
 *
 *  \brief:    Set or query the range of the ip when dhcp
 *  \operator: "="set, "?"query the current setting
 *  \param 0:  0:clear the param;1:set the param
 *  \param 1:  leave time [0-2880] second
 *  \param 2:  start ip
 *  \param 3:  end ip
 *  \return:   check result

 +----------------------------------------------------------------------------*/
#if 0
int at_net_dhcps(int argc, char *argv[], char *op[])		//dhcps
{

	dhcps_param *dhs_ptr;

	dhs_ptr = &g_atParam.dhs_param;
	if (!strcmp(op,"=")) {
		if (argc != 4)
			return at_ERR_HELP;
		if (strchr(argv[0], ' ') || strchr(argv[1], ' ') ||
			strchr(argv[2], ' ') || strchr(argv[3], ' '))
			return at_ERR_PARM;

		if (atoi(argv[0]) == 0) {
			reset_dhcp_ip_range();
		} else if(atoi(argv[0]) == 1) {
			int leavetime = atoi(argv[1]);
			char* startip = argv[2];
			char* endip = argv[3];
			int mix = 0,max = 0;

			if (!strcmp(dhs_ptr->startip, startip) &&
				!strcmp(dhs_ptr->endip, endip) &&
				(dhs_ptr->leave_time == leavetime))
				return at_ERR_OK;

			mix = checkIpValuable(startip);
			max = checkIpValuable(endip);
			serial_printf("<mix:%d><max:%d>\n",mix,max);

			if ((mix < 0) || (max < 0))
				return at_ERR_PARM;
			if ((leavetime < 1) || (leavetime > 2880))
				return at_ERR_PARM;

			set_dhcp_ip_range((unsigned char)mix,(unsigned char)max);
			set_dhcp_leavetime(leavetime);
			memcpy(dhs_ptr->startip,startip,16);
			memcpy(dhs_ptr->endip,endip,16);
			dhs_ptr->leave_time = leavetime;
			save_at_param();
			wifi_restart();
		} else {
			return at_ERR_HELP;
		}
	} else if(!strcmp(op,"=?")) {
		serial_printf("<leave time:%d><start ip:%s><end ip:%s>\n",
						dhs_ptr->leave_time,
						dhs_ptr->startip,
						dhs_ptr->endip);
	} else {
		return at_ERR_OP;
	}

	return at_ERR_OK;
}

#endif


/*!-----------------------------------------------------------------------------
 * function: at_net_ping
 *
 *  \brief:    Ping net address
 *  \operator: "="set
 *  \param 0:  destination address
 *  \param 1:  packet size
 *  \param 2:  iteration
 *  \param 3:  timeout
 *  \param 4:  interval
 *  \return:   check result
 +----------------------------------------------------------------------------*/
#if 0
int at_net_ping(int argc, char *argv[], char *op[])		//ping
{
	if (!strcmp(op,"=")) {
		unsigned int dip, size, iter, to, interval;

		if (argc <= 0)
			return at_ERR_HELP;
		if (strchr(argv[0], ' '))
			return at_ERR_PARM;
		size = iter = to = interval = 0;
		if ((argc > 0) && (inet_aton(argv[0], &dip) < 0))
			return at_ERR_HELP;
		if (argc > 1)
			size = atoi(argv[1]);
		if (argc > 2)
			iter = atoi(argv[2]);
		if (argc > 3)
			to = atoi(argv[3]);
		if (argc > 4)
			interval = atoi(argv[4]);
		net_ping(dip, &size, &iter, &to, &interval);
	} else {
		return at_ERR_OP;
	}
	return at_ERR_OK;
}
#endif
/*!-----------------------------------------------------------------------------
 * function: at_net_dns
 *
 *  \brief:    Set or query DNS server
 *  \operator: "="set, "=?"query the current setting
 *  \param 0:  server ID, 0-1
 *  \param 1:  address
 *  \return:   check result
 +----------------------------------------------------------------------------*/
#if 0
int at_net_dns(int argc, char *argv[], char *op[])		//dns
{
	unsigned int ipaddr;

	if (!strcmp(op,"=")) {
		if (argc != 2)
			return at_ERR_HELP;
		if (inet_aton(argv[1], &ipaddr) < 0)
			return at_ERR_HELP;
		net_set_dns(atoi(argv[0]), &ipaddr);
	} else if (!strcmp(op,"=?")) {
		if (argc != 1)
			return at_ERR_HELP;
		serial_printf("\n<%s>\n", net_get_dns(atoi(argv[0]), &ipaddr));
	} else {
		return at_ERR_OP;
	}
	return at_ERR_OK;
}
#endif

/*!-----------------------------------------------------------------------------
 * function: at_net_host
 *
 *  \brief:    Query host address
 *  \operator: "="set the current setting
 *  \param 0:  host name
 *  \return:   check result
 +----------------------------------------------------------------------------*/
#if 0
int at_net_host(int argc, char *argv[], char *op[])		//host
{
	if (!strcmp(op,"=")) {
		char hostname[256];
		char ipaddr[16]={0};

		memset(hostname, 0, sizeof(hostname));
		memset(ipaddr, 0, sizeof(ipaddr));
		if (argc != 1)
			return at_ERR_HELP;
		if (strchr(argv[0], ' '))
			return at_ERR_PARM;
		if (1 != sscanf(argv[0], "%s", hostname))
			return at_ERR_HELP;
		net_get_hostbyname(hostname, ipaddr);
		serial_printf("Server name %s  address: %s\n", hostname, ipaddr);
	} else {
		return at_ERR_OP;
	}
	return at_ERR_OK;
}
#endif

/*!-----------------------------------------------------------------------------
 * function: at_socket_add
 *
 *  \brief:    Establish a TCP or UDP connection.
 *  \operator: "="set the current setting
 *  \param 0:  socket ID
 *  \param 1:  socket type, TCP or UDP
 *  \param 2:  remote IP
 *  \param 3:  remote port, 0 ~ 65535
 *  \param 4:  [TCP:keeplive,UDP:lport]
 *  \return:   check result
 +----------------------------------------------------------------------------*/
#if 0
int at_socket_add(int argc, char *argv[], char *op[])	//sadd
{
/*
	if (!strcmp(op,"=")) {
		net_socket_mutiConn(1);
		if (net_socket_add(argc, argv) < 0)
			return at_ERR_PARM;
	} else {
		return at_ERR_OP;
	}
	tcp_rx_start();
*/
	return at_ERR_OK;
}
#endif

/*!-----------------------------------------------------------------------------
 * function: at_socket_del
 *
 *  \brief:    Delete TCP or UDP connection
 *  \operator: "="set the current setting
 *  \param 0:  socket ID
 *  \return:   check result
 +----------------------------------------------------------------------------*/
#if 0
int at_socket_del(int argc, char *argv[], char *op[])		//sdel
{
	if (!strcmp(op,"=")) {
		if (argc != 1)
			return at_ERR_HELP;
		if (net_socket_del(atoi(argv[0])) < 0)
			return at_ERR_PARM;
	} else {
		return at_ERR_OP;
	}
	tcp_rx_stop();
	return at_ERR_OK;
}

int checkExitTransMode(int len)
{
    if(len >= s_dataLenth && s_dataLenth > 0)
		return 1;

	return 0;
}

int getSendLength(void)
{
	return s_dataLenth;
}

int setSendLength(int len)
{
	s_dataLenth = len;
}

int start_trans_mode(void)
{
	trans_mode = 1;
	return 0;
}
#endif
/*!-----------------------------------------------------------------------------
 * function: at_socket_send
 *
 *  \brief:    Send data
 *  \operator: "="set the current setting
 *  \param 0:  socket ID
 *  \param 1:  length
 *  \return:   check result
 +----------------------------------------------------------------------------*/
#if 0
int at_socket_send(int argc, char *argv[], char *op[])	//ssend
{
	if (!strcmp(op,"=")) {
		if (argc == 1) {
			g_linkIdx = atoi(argv[0]);
			setSendLength(-1);
		} else if (argc == 2) {
			g_linkIdx = atoi(argv[0]);
			setSendLength(atoi(argv[1]));
		} else {
			return at_ERR_HELP;
		}
	} else if (!strcmp(op,NUL)) {
		g_linkIdx = 0;
		setSendLength(-1);
	} else {
		return at_ERR_OP;
	}
	
	if (check_socket_valiable(g_linkIdx)&&s_tsmodeEnable)
		trans_mode = 1;
	else
		serial_printf(" please enable the transmode or make sure socket is valid\n");

	return at_ERR_OK;
}
#endif
/*!-----------------------------------------------------------------------------
 * function: trans_mode
 *
 *  \brief:    Set module into transparent transmission mode
 *  \operator: NULL execute
 *  \return:   check result
 +----------------------------------------------------------------------------*/
#if 0
int at_trans_mode(int argc, char *argv[], char *op[])			//tmode
{
	if (!strcmp(op,"=")) {
		if (argc != 1)
			return at_ERR_PARM;

		s_tsmodeEnable = atoi(argv[0]);
		//trans_mode = atoi(argv[0]);
	} else if (!strcmp(op,"=?")) {
		serial_printf(" %d\n",s_tsmodeEnable);
	} else {
		return at_ERR_OP;
	}
	return at_ERR_TRANS;
}


#endif


#endif







