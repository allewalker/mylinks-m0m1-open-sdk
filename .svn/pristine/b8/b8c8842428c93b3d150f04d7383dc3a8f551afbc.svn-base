#include <c_types.h>
#include <minifs/mfs.h>
#include "fsconf.h"
#include "minifs.h"

struct minfo{
	uint32_t start;
	uint32_t fils;
	uint32_t version;
	uint32_t ctime;
};

struct minfo m;

DRESULT mfmount(uint32_t addr){
	struct minifs_head h;
	if(flash_read(addr, (uint32_t *) &h, sizeof(struct minifs_head))){
		return RES_NOTRDY;
	}
	if(strcmp(h.name,MINFS_NAME)){
		return RES_ERROR;
	}
	m.start = addr;
	m.fils = h.fils;
	m.ctime = h.ctime;
	m.version = h.version;
	return RES_OK;
}

uint32_t fstime(void){
	return m.ctime;
}

DRESULT mfopen(struct minifs *fs,char *fname){
	uint16_t flen;
	struct ftabs s;
	uint32_t i;
	uint32_t start;
	if(fname == NULL) return RES_ERROR;
	flen = strlen(fname);
	start = m.start + sizeof(struct minifs_head);
	for(i = 0 ; i < m.fils ; i++){
		if(flash_read(start,&s,sizeof(struct ftabs))){
			return RES_NOTRDY;
		}
//		serial_printf ("name:%s,len:%d,start:0x%x\n",s.fname,s.name_len,fs->start);

		if(s.name_len == flen && !strcmp(fname,s.fname)){
			fs->start = m.start + s.fil_local;
			fs->offset = 0;
			fs->fillen = s.fil_len;
			return RES_OK;
		}
		start+=sizeof(struct ftabs);
	}
	return RES_ERROR;
	
}

uint32_t mfread(struct minifs *fs,uint8_t *buf,uint32_t len){
	uint32_t rlen = fs->fillen - fs->offset;
	//获取还可以读取的数据长度
	len = (len > rlen)?rlen:len;
	if(!flash_read(fs->offset + fs->start,buf,len)){
		fs->offset += len;
		return len;
	}
	return 0;
}


uint32_t mftell(struct minifs *fs){
	return fs->fillen;
}


uint32_t mfseek(struct minifs *fs, long offset,SEEK fromwhere){
	switch(fromwhere){
		case SEEK_SET:
		if(offset < 0){
			fs->offset = 0;
		}else if(offset > fs->fillen){
			fs->offset = fs->fillen;
		}else{
			fs->offset = offset;
		}
		break;
		case SEEK_CUR:
		if((fs->offset + offset) > fs->fillen){
			fs->offset = fs->fillen;
		}else if((fs->offset + offset) < 0){
			fs->offset = 0;
		}else{
			fs->offset += offset;
		}
		break;
		case SEEK_END:
		if(offset > 0){
			fs->offset = fs->fillen;
		}else if((offset + fs->fillen) < 0){
			fs->offset = 0;
		}else{
			fs->offset = fs->fillen + offset;
		}
		break;
		default:
		fs->offset = 0;
		break;
	}
	return fs->offset;
}


