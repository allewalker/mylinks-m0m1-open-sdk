/*=============================================================================+
|                                                                              |
| Copyright 2012                                                               |
| Montage Inc. All right reserved.                                             |
|                                                                              |
+=============================================================================*/
/**
 * @file serial.c
 * @brief Serial port APIs
 *
 */
#include <lib_autoconf.h>
#include <c_types.h>
#include <socket_api.h>
#include <cfg_api_new.h>
#include <user_config.h>
#include <webserver/webserver.h>
#include <minifs/mfs.h>

#define READ_FILE_LEN 512
#define INDEX_HTML "index.html"
#define WEB_MATCH "\"7a80cd-5f8-80d86ad6\""


char match[sizeof(WEB_MATCH)];
webConn webconn;
static accept web_accept;



/**********************************************************************/
/* Get a line from a socket, whether the line ends in a newline,
 * carriage return, or a CRLF combination.  Terminates the string read
 * with a null character.  If no newline indicator is found before the
 * end of the buffer, the string is terminated with a null.  If any of
 * the above three line terminators is read, the last character of the
 * string will be a linefeed and the string will be terminated with a
 * null character.
 * Parameters: the socket descriptor
 *             the buffer to save the data in
 *             the size of the buffer
 * Returns: the number of bytes stored (excluding null) */
/**********************************************************************/
int get_line(int sock, char *buf, int size)  
{  
    int i = 0;  
    char c = '\0';  
    int n;
    //int nNetTimeout = 500;
  	//size --;
  	//setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&nNetTimeout,sizeof(int));
    /*把终止条件统一为 \n 换行符，标准化 buf 数组*/  
    while ((i < size - 1) && (c != '\n'))
    {  
        /*一次仅接收一个字节*/  
        n = recv(sock, &c, 1, 0);  
        /* DEBUG printf("%02X\n", c); */  
        if (n > 0)  
        {
        	//nNetTimeout = 50;
        	//setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&nNetTimeout,sizeof(int));  
            /*收到 \r 则继续接收下个字节，因为换行符可能是 \r\n */  
            if (c == '\r')  
            {  
                /*使用 MSG_PEEK 标志使下一次读取依然可以得到这次读取的内容，可认为接收窗口不滑动*/  
                n = recv(sock, &c, 1, MSG_PEEK);  
                /* DEBUG printf("%02X\n", c); */  
                /*但如果是换行符则把它吸收掉*/  
                if ((n > 0) && (c == '\n')){
                	recv(sock, &c, 1, 0); 
                }else{
                	c = '\n'; 
                }
            }  
            /*存到缓冲区*/  
            buf[i] = c;
            i++;
        }  
        else{
        	c = '\n';  
        }         
    }  
    buf[i] = '\0';  
  
    /*返回 buf 数组大小*/  
    return i;  
}

static void sockopt(int client_sock,int revTimeout,int sendTimeout){
	setsockopt(client_sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&revTimeout,sizeof(int));
	setsockopt(client_sock, SOL_SOCKET, SO_SNDTIMEO, (char *)&sendTimeout,sizeof(int));
	return;
}


static void get_match(void){
    struct minifs fs;

    if(RES_OK != mfopen(&fs,"match.txt")){
        memcpy(match,WEB_MATCH,sizeof(match));
        return; 
    }
    mfread(&fs,match,sizeof(match));

	return;
}


static char *get_file_path(accept *s,webConn *webconn){
    char *url = NULL;
    char *cgi = NULL;
    webconn->cgibin = 0;
    printf("url:%s\n",s->url);
	if(s->url[strlen(s->url) - 1] == '/'){
    	return INDEX_HTML;
    }
    url = s->url;
    if(*url == '/'){
    	url++;
    }
    cgi = (char *)strchr(url,'/');
    if(cgi == NULL){
        return url;
    }
    *cgi = '\0';
    if(!strcasecmp(url,"cgi-bin")){
        webconn->cgibin = 1;
        return (cgi+1);
    }
    return NULL;
}


static char *get_query_string(accept *s){
	char *path = NULL;
	char *query_string;
    query_string = (char *)strchr(s->url,'?');
    if(NULL == query_string){
        return NULL;
    } 
    /*开启 cgi */  
    *query_string = '\0';  
    query_string++;
    if(!strlen(query_string)){
    	return NULL;
    }
    return query_string;
}


static uint8_t cgibin(char *path){
	if(!strcasecmp(path, "cgi-bin")){
		return 1;
	}
	return 0;
}




void accept_free(accept *s){
	if(s->buf){
		free(s->buf);
		s->buf = NULL;
	}
	if(s->method){
		free(s->method);
		s->method = NULL;
	}
	if(s->url){
		free(s->url);
		s->url = NULL;
	}
	return;
}


static int8_t accept_init(accept *s){
	s->buf = (char *)zalloc(BUF_LEN);
	s->method = (char *)zalloc(METHOD_LEN);
	s->url = (char *)zalloc(URL_LEN);
	if(NULL == s->buf || NULL == s->method || NULL == s->url){
		return -1;
	}
	return 0;
}


static void get_method(accept *web_accept){
	size_t i = 0, j = 0;
	/*把客户端的请求方法存到 method 数组*/  
    while (!ISspace(web_accept->buf[j]) && (i < (METHOD_LEN - 1)))  
    {  
        web_accept->method[i] = web_accept->buf[j];  
        i++; j++;  
    }
    web_accept->method[i] = '\0';
	/*读取 url 地址*/  
    i = 0;  
    while (ISspace(web_accept->buf[j]) && (j < BUF_LEN)){
    	j++;  
    }    
    while (!ISspace(web_accept->buf[j]) && (i < URL_LEN - 1) && (j < BUF_LEN))  
    {  
        /*存下 url */  
        web_accept->url[i] = web_accept->buf[j];  
        i++; j++;  
    }  
    web_accept->url[i] = '\0';
    return;
}


static void head_handle(int client,webConn *webconn,accept *web_accept){
	int numchars;
	char *check;
	size_t i = 0, j = 0;
	webconn->encrypt = 1;
    webconn->cache = 0;
    webconn->postLen = -1;
	/* read & discard headers */  
	//这里用来处理数据
	do{
    	numchars = get_line(client, web_accept->buf, BUF_LEN);
        //printf(web_accept->buf);
    	i = 0, j = 0;
		/*把客户端的请求方法存到 method 数组*/  
		while (!ISspace(web_accept->buf[j]) && (i < (METHOD_LEN - 1)))  
		{
			web_accept->method[i] = web_accept->buf[j];  
			i++; j++;  
		}
		web_accept->method[i] = '\0';
		i = 0;  
		while (ISspace(web_accept->buf[j]) && (j < BUF_LEN)){
			j++;  
		}
        
		if(!strcasecmp(web_accept->method, "Host:")){
			while (!ISspace(web_accept->buf[j]) && (i < URL_LEN - 1) && (j < BUF_LEN))  
			{
				web_accept->method[i] = web_accept->buf[j];
				i++; j++;  
		    }
		    web_accept->method[i] = '\0';
		    if(!strcasecmp(web_accept->method,"captive.apple.com")){
				webconn->encrypt = 1;
			}
		}else if(!strcasecmp(web_accept->method, "Content-Length:")){
			while (!ISspace(web_accept->buf[j]) && (i < URL_LEN - 1) && (j < BUF_LEN))  
			{
				web_accept->method[i] = web_accept->buf[j];
				i++; j++;  
		    }
		    web_accept->method[i] = '\0';
		    webconn->postLen = atoi(web_accept->method);
		}
/*
		else if(!strcasecmp(web_accept->method, "Authorization:")){
			while (!ISspace(web_accept->buf[j]) && (i < URL_LEN - 1) && (j < BUF_LEN))  
			{
				web_accept->method[i] = web_accept->buf[j];
				i++; j++;  
			}
			web_accept->method[i] = '\0';
			if(strcasecmp(web_accept->method, "Basic")){
				break;
		    }
			i = 0;  
			while (ISspace(web_accept->buf[j]) && (j < BUF_LEN)){
				j++;  
			}
			//这里计算出认证的内容
			while (!ISspace(web_accept->buf[j]) && (i < URL_LEN - 1) && (j < BUF_LEN))  
			{
				web_accept->method[i] = web_accept->buf[j];
				i++; j++;  
			}
			web_accept->method[i] = '\0';
			check = (char *)zalloc(METHOD_LEN);
			if(check){
				base64_decode(web_accept->method,check);
				//printf("check:%s\n", web_accept->method);
				if(!memcmp(check,sysCfg.web_user,strlen(sysCfg.web_user)) && !strcmp(check + strlen(sysCfg.web_user)+1,sysCfg.web_passwd)){
					webconn->encrypt = 1;
				}
				free(check);
			}

		}

        else if(!strcasecmp(web_accept->method,"Cache-Control:")){
            webconn->cache = 1;
        }
        */
		else if(!strcasecmp(web_accept->method,"If-None-Match:")){
            while (!ISspace(web_accept->buf[j]) && (i < URL_LEN - 1) && (j < BUF_LEN))  
            {
                web_accept->method[i] = web_accept->buf[j];
                i++; j++;  
            }
            web_accept->method[i] = '\0';
            if(!strcasecmp(web_accept->method,match)){
                webconn->cache = 1;
                printf("cache\r\n");
            }
        }
	}while ((numchars > 0) && strcmp("\n", web_accept->buf));
	return;	
}

const fType WebType[]={
    {JS,2,"js","application/x-javascript"},
    {CSS,3,"css","text/css"},
    {PNG,3,"png","image/png"},
    {JPG,3,"jpg","image/jpeg"},
    {ICO,3,"ico","image/x-icon"},
    {TEXT,4,"html","text/html"},
    {GIF,3,"gif","image/gif"},
    {MO,2,"mo",NULL},
    {FTYPEMAX,0,NULL,NULL},
};


fileType getFileType(char *filetype){
    fType *s = NULL;
    for(s = (fType *)WebType;s->type != FTYPEMAX;s++){
        if(!memcmp(filetype,s->name,s->typelen)){
            return s->type;
        }        
    }
    return TEXT;
}

char *getTypeString(const char *stop,char *start){
    for(;start > stop;start--){
        if(*start == '.'){
            return (start + 1);
        }
    }
    return NULL;
}


/**********************************************************************/
/* Return the informational HTTP headers about a file. */
/* Parameters: the socket to print the headers on
 *             the name of the file */
/**********************************************************************/

int headers(int client, const char *filename,struct minifs *fs)
{
 char *buf;
 int resource;
 char *dot;
 uint8_t gzip = 0;
 fileType type;

 resource = mfopen(fs,(char *)filename);
 if(resource < 0){
#if PRINT_FLAG
    printf("cant find file\n");
#endif
    webconn.cache = 0;
    return -1;    
 }

 //获取文件的类型
 dot = (char *)filename + strlen(filename) - 1;
 dot = getTypeString(filename,dot);
 if(NULL == dot){
    webconn.cache = 0;
#if PRINT_FLAG
    printf("err -1\n");
#endif
    return -1;    
 }
 type = getFileType(dot);


 //如果是劢领的压缩格式，则再做一次查的
 if(MO == type){
    gzip = 1;
    dot = getTypeString(filename,dot - 2);
    if(NULL == dot){
        webconn.cache = 0;
#if PRINT_FLAG
    printf("err -2\n");
#endif
        return -1;    
    }
    type = getFileType(dot);
    printf("dot:%s,type:%d\n",dot,type);
 }

 if(webconn.cache){
    //如果是自己的脚本和TEXT文件，则每次都要正常加载
    if(gzip){
        return -1; 
    }
    webconn.cache = 0; 
 }

 buf = (char *)zalloc(CONTENT_LEN);
 if( NULL == buf ){
    webconn.cache = 0;
    return -1;
 }
 STRSEND(client,"HTTP/1.1 200 OK");
 STRSEND(client,"\r\n");
 STRSEND(client,SERVER_STRING);
 STRSEND(client,"Content-Type: ");

 send(client,WebType[type].ctype,strlen(WebType[type].ctype),0);
 if(TEXT == type){
    STRSEND(client,"; ");
    STRSEND(client,"charset=gbk");
    STRSEND(client,"\r\n");
 }else{
   STRSEND(client,"\r\n");
   send_cache_header(client);      
 } 

  if(gzip){
#if PRINT_FLAG
    printf("gzip\n");
#endif
    STRSEND(client,"Content-Encoding: gzip");
    STRSEND(client,"\r\n");
 }

 sprintf(buf,"Content-Length: %d",mftell(fs));
 send(client,buf,strlen(buf),0);
 STRSEND(client,"\r\n");
 STRSEND(client,"Connection: Close");
 STRSEND(client,"\r\n");
 STRSEND(client,"\r\n");
 free(buf);
 return resource;
}

/**********************************************************************/
/* Put the entire contents of a file out on a socket.  This function
 * is named after the UNIX "cat" command, because it might have been
 * easier just to do something like pipe, fork, and exec("cat").
 * Parameters: the client socket descriptor
 *             FILE pointer for the file to cat */
/**********************************************************************/
void cat(int client,struct minifs *fs)
{
#if 1
 char *buf;
 int16_t postLen;
 int wirteLen;
 buf = (char *)zalloc(READ_FILE_LEN);
 if(NULL == buf){
 	return;
 }
 do{
    postLen = mfread(fs,buf,READ_FILE_LEN);
    //printf("read len:%d\r\n",postLen);
    //printf("heap:%d\n", system_get_free_heap_size());
    if(postLen > 0){
        wirteLen = send(client,buf,postLen,0);
        if(wirteLen !=postLen){
            break;
        }
    }else{
        break;
    }
 }while(postLen ==  READ_FILE_LEN);
 free(buf);
#endif
 return;
}





/**********************************************************************/
/* Send a regular file to the client.  Use headers, and report
 * errors to client if they occur.
 * Parameters: a pointer to a file structure produced from the socket
 *              file descriptor
 *             the name of the file to serve */
/**********************************************************************/
void serve_file(int client, const char *filename)
{
    struct minifs fs;
    if(RES_OK == headers(client, filename,&fs)){
        cat(client,&fs);
        return;
    }
    if(webconn.cache){
        file_cache(client);
    }else{
        not_found(client,filename);
    }
    return;
}


static void accept_request(int client,webConn *conn){
	char *query_string = NULL;
	char *path = NULL;
	if(accept_init(&web_accept) < 0){
		requesttimeout(client);
		goto REQUEST;
	}
	if(!get_line(client, web_accept.buf, BUF_LEN)){
		requesttimeout(client);
		goto REQUEST;		
	}
    //printf(web_accept.buf);
	get_method(&web_accept);
	query_string = get_query_string(&web_accept);
	
	if(!strcasecmp(web_accept.method, "GET")){
		conn->type = GET;
	}else if(!strcasecmp(web_accept.method, "POST")){
		conn->type = POST;
	}else if(!strcasecmp(web_accept.method, "HEAD")){
		conn->type = HEAD;
	}else{
        unimplemented(client);  
        goto REQUEST;  	
    }
    //获取打开的文件
    path = get_file_path(&web_accept,conn);
    printf("path:%s\n",path);
    head_handle(client,&webconn,&web_accept);
    if(webconn.type == HEAD){
    	authfaild(client);
    	goto REQUEST;
    }
    if(!webconn.encrypt){
        authfaild(client);
        goto REQUEST;
    }
    if(NULL == query_string){
    	if(GET == webconn.type){
            serve_file(client,path);
    	}

    }else{
        
    }
REQUEST:
    accept_free(&web_accept);
	return;
}


void  createWebServer( void *arg ){
	int32_t listenfd;
	int32_t ret;
	struct sockaddr_in *server_addr;
	struct sockaddr_in *remote_addr;
    get_match();
	server_addr = (struct sockaddr_in *)zalloc(sizeof(struct sockaddr_in));
	remote_addr = (struct sockaddr_in *)zalloc(sizeof(struct sockaddr_in));
	/* Construct local address structure */
	memset(server_addr, 0, sizeof(struct sockaddr_in)); /* Zero out structure */
	server_addr->sin_family = AF_INET; /* Internet address family */
	server_addr->sin_addr.s_addr = INADDR_ANY; /* Any incoming interface */
	server_addr->sin_len = sizeof(struct sockaddr_in);
	server_addr->sin_port = htons(80); /* Local port */
	/* Create socket for incoming connections */
	do{
		listenfd = socket(AF_INET, SOCK_STREAM, 0);
		if (listenfd == -1) {
#if PRINT_FLAG
			printf("TCP server task > socket error\n");
#endif
			sys_msleep(100);
		}
	}while(listenfd == -1);

	/* Bind to the local port */
	do{
		ret = bind(listenfd, (struct sockaddr *)server_addr,sizeof(struct sockaddr_in));
		if (ret != 0) {
#if PRINT_FLAG
			printf("TCP server task > bind fail\n");
#endif
			sys_msleep(100);
		}
	}while(ret != 0);
	do{
		/* Listen to the local connection */
		ret = listen(listenfd, 4);
		if (ret != 0) {
#if PRINT_FLAG
			printf("TCP server task > failed to set listen queue!\n");
#endif
			sys_msleep(100);
		}

	}while(ret != 0);

	int32_t sock;
	int32_t len = sizeof(struct sockaddr_in);
	for(;;){
#if PRINT_FLAG
		printf("TCP server task > wait client\n");
#endif
		sock = accept(listenfd, (struct sockaddr *)remote_addr,(socklen_t *)&len);
		/*block here waiting remote connect request*/
		if(sock < 0){
#if PRINT_FLAG
			printf("TCP server task > accept fail\n");
#endif
			continue;
		}
		sockopt(sock,1000,500);
		accept_request(sock,&webconn);
		close(sock);
	}
	vTaskDelete(NULL);	
}


void webserver_init(void){
    if (!xTaskGenericCreate( createWebServer, "webserver", TASK_HEAP_LEN, NULL, 6, NULL,  NULL ,  NULL  )) {
        return;
    }
    return;
}





