/*=============================================================================+
|                                                                              |
| Copyright 2012                                                               |
| Montage Inc. All right reserved.                                             |
|                                                                              |
+=============================================================================*/
/**
 * @file serial.c
 * @brief Serial port APIs
 *
 */
#include <lib_autoconf.h>
#include <c_types.h>
#include <socket_api.h>
#include <cfg_api_new.h>
#include <user_config.h>
#include <webserver/webserver.h>
#include <minifs/mfs.h>

#define READ_FILE_LEN 1460
#define INDEX_HTML "index.html"
#define WEB_MATCH "\"7a80cd-5f8-80d86ad6\""

typedef struct{
    uint8_t name_len;
    char *mylinks_dns;
}DNSTYPE;

DNSTYPE mydns;


char match[sizeof(WEB_MATCH)];
webConn webconn;
static accept web_accept = {NULL,NULL,NULL};
static const uint8_t apple_dns[] = {0x7,'c','a','p','t','i','v','e',0x5,'a','p','p','l','e',0x3,'c','o','m'};
//static const uint8_t mylinks_dns[] = {0x3,'s','e','t',0x7,'m','q','l','i','n','k','s',0x3,'c','o','m'};;
static const uint8_t dns_ok[] = {0xc0,0x0c,0x00,0x01,0x00,0x01,0x00,0x00,0x58,0x58,0x00,0x04,192,168,4,1};



/**********************************************************************/
/* Get a line from a socket, whether the line ends in a newline,
 * carriage return, or a CRLF combination.  Terminates the string read
 * with a null character.  If no newline indicator is found before the
 * end of the buffer, the string is terminated with a null.  If any of
 * the above three line terminators is read, the last character of the
 * string will be a linefeed and the string will be terminated with a
 * null character.
 * Parameters: the socket descriptor
 *             the buffer to save the data in
 *             the size of the buffer
 * Returns: the number of bytes stored (excluding null) */
/**********************************************************************/
int get_line(int sock, char *buf, int size)  
{  
    int i = 0;  
    char c = '\0';  
    int n;
    //int nNetTimeout = 500;
  	//size --;
  	//setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&nNetTimeout,sizeof(int));
    /*把终止条件统一为 \n 换行符，标准化 buf 数组*/  
    while ((i < size - 1) && (c != '\n'))
    {  
        /*一次仅接收一个字节*/  
        n = recv(sock, &c, 1, 0);  
        /* DEBUG printf("%02X\n", c); */  
        if (n > 0)  
        {
        	//nNetTimeout = 50;
        	//setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&nNetTimeout,sizeof(int));  
            /*收到 \r 则继续接收下个字节，因为换行符可能是 \r\n */  
            if (c == '\r')  
            {  
                /*使用 MSG_PEEK 标志使下一次读取依然可以得到这次读取的内容，可认为接收窗口不滑动*/  
                n = recv(sock, &c, 1, MSG_PEEK);  
                /* DEBUG printf("%02X\n", c); */  
                /*但如果是换行符则把它吸收掉*/  
                if ((n > 0) && (c == '\n')){
                	recv(sock, &c, 1, 0); 
                    /*存到缓冲区*/  

                }else{
                	c = '\n'; 
                }
            }  
            /*存到缓冲区*/  
            buf[i] = c;
            i++;
        }  
        else{
        	c = '\n';  
        }         
    }  
    buf[i] = '\0';  
  
    /*返回 buf 数组大小*/  
    return i;  
}

static void sockopt(int client_sock,int revTimeout,int sendTimeout){
	setsockopt(client_sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&revTimeout,sizeof(int));
	setsockopt(client_sock, SOL_SOCKET, SO_SNDTIMEO, (char *)&sendTimeout,sizeof(int));
	return;
}


static void get_match(void){
    struct minifs fs;

    if(RES_OK != mfopen(&fs,"match.txt")){
        memcpy(match,WEB_MATCH,sizeof(match));
        return; 
    }
    mfread(&fs,match,sizeof(match));

	return;
}


static char *get_file_path(accept *s,webConn *webconn){
    char *url = NULL;
    char *cgi = NULL;
    webconn->cgibin = 0;
	if(s->url[strlen(s->url) - 1] == '/'){
    	return INDEX_HTML;
    }
    url = s->url;
    if(*url == '/'){
    	url++;
    }
    cgi = (char *)strchr(url,'/');
    if(cgi == NULL){
        return url;
    }
    *cgi = '\0';
    if(!strcasecmp(url,"cgi-bin")){
        webconn->cgibin = 1;
        return (cgi+1);
    }
    return NULL;
}


static char *get_query_string(accept *s){
	char *path = NULL;
	char *query_string;
    query_string = (char *)strchr(s->url,'?');
    if(NULL == query_string){
        return NULL;
    } 
    /*开启 cgi */  
    *query_string = '\0';  
    query_string++;
    if(!strlen(query_string)){
    	return NULL;
    }
    return query_string;
}


static uint8_t cgibin(char *path){
	if(!strcasecmp(path, "cgi-bin")){
		return 1;
	}
	return 0;
}




void accept_free(accept *s){
	if(s->buf){
		free(s->buf);
		s->buf = NULL;
	}
	if(s->method){
		free(s->method);
		s->method = NULL;
	}
	if(s->url){
		free(s->url);
		s->url = NULL;
	}
	return;
}


static int8_t accept_init(accept *s){
    if(NULL == s->buf){
        s->buf = (char *)malloc(BUF_LEN);
    }
    if(NULL == s->method){
        s->method = (char *)malloc(METHOD_LEN);
    }
    if(NULL == s->url){
        s->url = (char *)malloc(URL_LEN);
    }
	
	return (NULL == s->buf || NULL == s->method || NULL == s->url)? -1:0;
}


static void get_method(accept *web_accept){
	size_t i = 0, j = 0;
	/*把客户端的请求方法存到 method 数组*/  
    while (!ISspace(web_accept->buf[j]) && (i < (METHOD_LEN - 1)))  
    {  
        web_accept->method[i] = web_accept->buf[j];  
        i++; j++;  
    }
    web_accept->method[i] = '\0';
	/*读取 url 地址*/  
    i = 0;  
    while (ISspace(web_accept->buf[j]) && (j < BUF_LEN)){
    	j++;  
    }    
    while (!ISspace(web_accept->buf[j]) && (i < URL_LEN - 1) && (j < BUF_LEN))  
    {  
        /*存下 url */  
        web_accept->url[i] = web_accept->buf[j];  
        i++; j++;  
    }  
    web_accept->url[i] = '\0';
    return;
}


static void head_handle(int client,webConn *webconn,accept *web_accept){
	int numchars;
	char *check;
	size_t i = 0, j = 0;
	webconn->encrypt = 1;
    webconn->cache = 0;
    webconn->nocache = 0;
    webconn->keepalive = 0;
    webconn->postLen = -1;
	/* read & discard headers */  
	//这里用来处理数据
	do{
    	numchars = get_line(client, web_accept->buf, BUF_LEN);
        //printf("len:%d\n",numchars);
    	i = 0, j = 0;
		/*把客户端的请求方法存到 method 数组*/  
		while (!ISspace(web_accept->buf[j]) && (i < (METHOD_LEN - 1)))  
		{
			web_accept->method[i] = web_accept->buf[j];  
			i++; j++;  
		}
		web_accept->method[i] = '\0';
		i = 0;  
		while (ISspace(web_accept->buf[j]) && (j < BUF_LEN)){
			j++;  
		}
        
		if(!strcasecmp(web_accept->method, "Host:")){
			while (!ISspace(web_accept->buf[j]) && (i < URL_LEN - 1) && (j < BUF_LEN))  
			{
				web_accept->method[i] = web_accept->buf[j];
				i++; j++;  
		    }
		    web_accept->method[i] = '\0';
		    if(!strcasecmp(web_accept->method,"captive.apple.com")){
				webconn->encrypt = 1;
			}
		}else if(!strcasecmp(web_accept->method, "Content-Length:")){
			while (!ISspace(web_accept->buf[j]) && (i < URL_LEN - 1) && (j < BUF_LEN))  
			{
				web_accept->method[i] = web_accept->buf[j];
				i++; j++;  
		    }
		    web_accept->method[i] = '\0';
		    webconn->postLen = atoi(web_accept->method);
		}
/*
        else if(!strcasecmp(web_accept->method, "Connection:")){
            while (!ISspace(web_accept->buf[j]) && (i < URL_LEN - 1) && (j < BUF_LEN))  
            {
                web_accept->method[i] = web_accept->buf[j];
                i++; j++;  
            }
            web_accept->method[i] = '\0';
            if(!strcasecmp(web_accept->method,"keep-alive")){
                webconn->keepalive = 1;
                //printf("cache\r\n");
            }
        }

		else if(!strcasecmp(web_accept->method, "Authorization:")){
			while (!ISspace(web_accept->buf[j]) && (i < URL_LEN - 1) && (j < BUF_LEN))  
			{
				web_accept->method[i] = web_accept->buf[j];
				i++; j++;  
			}
			web_accept->method[i] = '\0';
			if(strcasecmp(web_accept->method, "Basic")){
				break;
		    }
			i = 0;  
			while (ISspace(web_accept->buf[j]) && (j < BUF_LEN)){
				j++;  
			}
			//这里计算出认证的内容
			while (!ISspace(web_accept->buf[j]) && (i < URL_LEN - 1) && (j < BUF_LEN))  
			{
				web_accept->method[i] = web_accept->buf[j];
				i++; j++;  
			}
			web_accept->method[i] = '\0';
			check = (char *)zalloc(METHOD_LEN);
			if(check){
				base64_decode(web_accept->method,check);
				//printf("check:%s\n", web_accept->method);
				if(!memcmp(check,sysCfg.web_user,strlen(sysCfg.web_user)) && !strcmp(check + strlen(sysCfg.web_user)+1,sysCfg.web_passwd)){
					webconn->encrypt = 1;
				}
				free(check);
			}

		}
        */
        else if(!strcasecmp(web_accept->method,"Cache-Control:")){
            while (!ISspace(web_accept->buf[j]) && (i < URL_LEN - 1) && (j < BUF_LEN))  
            {
                web_accept->method[i] = web_accept->buf[j];
                i++; j++;  
            }
            web_accept->method[i] = '\0';
            if(!strcasecmp(web_accept->method,"no-cache")){
                webconn->nocache = 1;
            }else if(!strcasecmp(web_accept->method,"private")){
                webconn->nocache = 1;
            }else if(!strcasecmp(web_accept->method,"must-revalidate")){
                 webconn->nocache = 1;
            }
        }

		else if(!strcasecmp(web_accept->method,"If-None-Match:")){
            while (!ISspace(web_accept->buf[j]) && (i < URL_LEN - 1) && (j < BUF_LEN))  
            {
                web_accept->method[i] = web_accept->buf[j];
                i++; j++;  
            }
            web_accept->method[i] = '\0';
            if(!strcasecmp(web_accept->method,match)){
                webconn->cache = 1;
                webconn->nocache = 1;
                //printf("cache\r\n");
            }
        }
	}while (numchars > 1/* && strcmp("\n", web_accept->buf)*/);
	return;	
}

const fType WebType[]={
    {JS,2,"js","application/x-javascript"},
    {CSS,3,"css","text/css"},
    {PNG,3,"png","image/png"},
    {JPG,3,"jpg","image/jpeg"},
    {ICO,3,"ico","image/x-icon"},
    {TEXT,4,"html","text/html"},
    {GIF,3,"gif","image/gif"},
    {MO,2,"mo",NULL},
    {FTYPEMAX,0,NULL,NULL},
};


fileType getFileType(char *filetype){
    fType *s = NULL;
    for(s = (fType *)WebType;s->type != FTYPEMAX;s++){
        if(!memcmp(filetype,s->name,s->typelen)){
            return s->type;
        }        
    }
    return TEXT;
}

char *getTypeString(const char *stop,char *start){
    for(;start > stop;start--){
        if(*start == '.'){
            return (start + 1);
        }
    }
    return NULL;
}


/**********************************************************************/
/* Return the informational HTTP headers about a file. */
/* Parameters: the socket to print the headers on
 *             the name of the file */
/**********************************************************************/

int headers(int client, const char *filename,struct minifs *fs)
{
 char *buf;
 int resource;
 char *dot;
 uint8_t gzip = 0;
 fileType type;

 resource = mfopen(fs,(char *)filename);
 if(resource < 0){
    webconn.cache = 0;
    return -1;    
 }

 //获取文件的类型
 dot = (char *)filename + strlen(filename) - 1;
 dot = getTypeString(filename,dot);
 if(NULL == dot){
    webconn.cache = 0;
    return -1;    
 }
 type = getFileType(dot);


 //如果是劢领的压缩格式，则再做一次查的
 if(MO == type){
    gzip = 1;
    dot = getTypeString(filename,dot - 2);
    if(NULL == dot){
        webconn.cache = 0;

        return -1;    
    }
    type = getFileType(dot);
 }

#if 1
 if(webconn.cache && gzip){
    //如果是自己的脚本和TEXT文件，则每次都要正常加载
    return -1;
 }
 webconn.cache = 0; 
#endif
 buf = (char *)malloc(CONTENT_LEN);
 if( NULL == buf ){
    webconn.cache = 0;
    return -1;
 }
 STRSEND(client,"HTTP/1.1 200 OK");
 STRSEND(client,"\r\n");
 STRSEND(client,SERVER_STRING);
 STRSEND(client,"Content-Type: ");

 send(client,WebType[type].ctype,strlen(WebType[type].ctype),0);
 if(TEXT == type){
    STRSEND(client,"; ");
    STRSEND(client,"charset=gbk");
    STRSEND(client,"\r\n");
 }else{
   STRSEND(client,"\r\n");
   send_cache_header(client);      
 } 

  if(gzip){
    STRSEND(client,"Content-Encoding: gzip");
    STRSEND(client,"\r\n");
 }

 sprintf(buf,"Content-Length: %d",mftell(fs));
 STRSEND(client,buf);
// send(client,buf,strlen(buf),0);
 STRSEND(client,"\r\n");
 STRSEND(client,"Connection: ");

 if(webconn.nocache){
    webconn.keepalive = 0;
 }
 if(webconn.keepalive){
    STRSEND(client,"Keep-alive");
 }else{
    STRSEND(client,"Close");
 }
    
 STRSEND(client,"\r\n");
 STRSEND(client,"\r\n");
 free(buf);
 return resource;
}

/**********************************************************************/
/* Put the entire contents of a file out on a socket.  This function
 * is named after the UNIX "cat" command, because it might have been
 * easier just to do something like pipe, fork, and exec("cat").
 * Parameters: the client socket descriptor
 *             FILE pointer for the file to cat */
/**********************************************************************/
static void cat(int client,struct minifs *fs)
{
#if 1
 char *buf;
 int16_t postLen;
 int wirteLen;
 wirteLen = mftell(fs);
 buf = (char *)malloc((wirteLen > READ_FILE_LEN)?READ_FILE_LEN:wirteLen);
 if(NULL == buf){
 	return;
 }
 do{
    postLen = mfread(fs,buf,READ_FILE_LEN);
    if(postLen <= 0){
        break;
    }
    //printf("read len:%d\r\n",postLen);
    //printf("heap:%d\n", system_get_free_heap_size());
    wirteLen = send(client,buf,postLen,0);
    if(wirteLen != postLen){
        break;
    }
 }while(postLen ==  READ_FILE_LEN);
 free(buf);
#endif
 return;
}





/**********************************************************************/
/* Send a regular file to the client.  Use headers, and report
 * errors to client if they occur.
 * Parameters: a pointer to a file structure produced from the socket
 *              file descriptor
 *             the name of the file to serve */
/**********************************************************************/
void serve_file(int client, const char *filename)
{
    struct minifs fs;
    if(RES_OK == headers(client, filename,&fs)){
        cat(client,&fs);
        return;
    }
    webconn.keepalive = 0;
    if(webconn.cache){
        file_cache(client);
    }else{
        not_found(client,filename);
    }
    return;
}


static void accept_request(int client,webConn *conn){
	char *query_string = NULL;
	char *path = NULL;
    do{
        if(accept_init(&web_accept) < 0){
            requesttimeout(client);
            goto REQUEST;
        }
        if(!get_line(client, web_accept.buf, BUF_LEN)){
            requesttimeout(client);
            goto REQUEST;       
        }
        //printf(web_accept.buf);
        get_method(&web_accept);
        query_string = get_query_string(&web_accept);
        
        if(!strcasecmp(web_accept.method, "GET")){
            conn->type = GET;
        }else if(!strcasecmp(web_accept.method, "POST")){
            conn->type = POST;
        }else if(!strcasecmp(web_accept.method, "HEAD")){
            conn->type = HEAD;
        }else{
            unimplemented(client);  
            goto REQUEST;   
        }
        //获取打开的文件
        path = get_file_path(&web_accept,conn);
        printf("path:%s\n",path);
        head_handle(client,conn,&web_accept);
        if(conn->type == HEAD){
            authfaild(client);
            goto REQUEST;
        }
        if(!conn->encrypt){
            authfaild(client);
            goto REQUEST;
        }
        if(NULL == query_string){
            if(GET == conn->type){
                serve_file(client,path);
            }

        }else{
            
        }        
    }while(conn->keepalive);

REQUEST:
    
    accept_free(&web_accept);
    
	return;
}


void  createWebServer( void *arg ){
	int32_t listenfd;
	int32_t ret;
	struct sockaddr_in *server_addr;
	struct sockaddr_in *remote_addr;
    get_match();
	server_addr = (struct sockaddr_in *)malloc(sizeof(struct sockaddr_in));
	remote_addr = (struct sockaddr_in *)malloc(sizeof(struct sockaddr_in));
	/* Construct local address structure */
	memset(server_addr, 0, sizeof(struct sockaddr_in)); /* Zero out structure */
	server_addr->sin_family = AF_INET; /* Internet address family */
	server_addr->sin_addr.s_addr = INADDR_ANY; /* Any incoming interface */
	server_addr->sin_len = sizeof(struct sockaddr_in);
	server_addr->sin_port = htons(80); /* Local port */


	/* Create socket for incoming connections */
	do{
		listenfd = socket(AF_INET, SOCK_STREAM, 0);
		if (listenfd == -1) {
#if PRINT_FLAG
			printf("TCP server task > socket error\n");
#endif
			sys_msleep(100);
		}
	}while(listenfd == -1);

	/* Bind to the local port */
	do{
		ret = bind(listenfd, (struct sockaddr *)server_addr,sizeof(struct sockaddr_in));
		if (ret != 0) {
#if PRINT_FLAG
			printf("TCP server task > bind fail\n");
#endif
			sys_msleep(100);
		}
	}while(ret != 0);
	do{
		/* Listen to the local connection */
		ret = listen(listenfd, 1);
		if (ret != 0) {
#if PRINT_FLAG
			printf("TCP server task > failed to set listen queue!\n");
#endif
			sys_msleep(100);
		}

	}while(ret != 0);


	int32_t sock;
	int32_t len = sizeof(struct sockaddr_in);
    fd_set fdsr;  
    struct timeval tv;

	for(;;){
        sock = accept(listenfd, (struct sockaddr *)remote_addr,(socklen_t *)&len);
            
            /*block here waiting remote connect request*/
        if(sock < 0){
    #if PRINT_FLAG
            printf("TCP server task > accept fail\n");
    #endif
            continue;
        }
        FD_ZERO(&fdsr);
        FD_SET(sock, &fdsr);
            //增加一个超时的检测机制
        tv.tv_sec = 0;  
        tv.tv_usec = 600000;   
        ret = select(sock + 1, &fdsr, NULL, NULL, &tv);
        if(ret > 0 && FD_ISSET(sock, &fdsr)){
            sockopt(sock,180,300);
            accept_request(sock,&webconn);                     
        }
        close(sock);
#if PRINT_FLAG
        printf("TCP server task > wait\n");
#endif     
	}
	vTaskDelete(NULL);
}


void webserver_init(void){
    xTaskGenericCreate( createWebServer, "webserver", TASK_HEAP_LEN + (TASK_HEAP_LEN>>1), NULL, 6, NULL,  NULL ,  NULL  );
    return;
}
void  createDnsServer( void *arg ){
    int nNetTimeout = 0;
    socklen_t fromlen;

    //此部分为DNS
    dnsHead *dns_head;
    uint8_t *udp_msg;
    struct sockaddr *from;
    struct sockaddr_in *dns_server_addr;
    int32_t ret;
    int32_t sock_fd;

    from = (struct sockaddr *)malloc(sizeof(struct sockaddr));
    udp_msg = (uint8_t *)zalloc(256);
    dns_server_addr = (struct sockaddr_in *)malloc(sizeof(struct sockaddr_in));
    memset(dns_server_addr, 0, sizeof(struct sockaddr_in));
    dns_server_addr->sin_family = AF_INET;
    dns_server_addr->sin_addr.s_addr = INADDR_ANY;
    dns_server_addr->sin_port = htons(53);
    dns_server_addr->sin_len = sizeof(struct sockaddr_in);
    sock_fd = socket(AF_INET, SOCK_DGRAM, 0);
    ret = bind(sock_fd, (struct sockaddr *)dns_server_addr, sizeof(struct sockaddr_in));

    for(;;){
        fromlen = sizeof(struct sockaddr_in);
        ret = recvfrom(sock_fd, (uint8 *)udp_msg, 256, 0,(struct sockaddr*)from,(socklen_t *)&fromlen);
        if (ret <= 0) {
            continue;
        }
        dns_head = (dnsHead *)udp_msg;
        if((dns_head->numQ!=0x1) || (dns_head->tag!=0x100)){
            //printf("other type:%d,%d\n",sw16(dns_head->numQ),sw16(dns_head->tag));
            continue;
        }
        if(!memcmp(udp_msg + sizeof(dnsHead),mydns.mylinks_dns,mydns.name_len)||!memcmp(udp_msg + sizeof(dnsHead),apple_dns,sizeof(apple_dns))){
        //if(!memcmp(udp_msg + sizeof(dnsHead),mylinks_dns,sizeof(mylinks_dns))||!memcmp(udp_msg + sizeof(dnsHead),apple_dns,sizeof(apple_dns))){
            //printf("dns:%s\n",udp_msg + sizeof(dnsHead));
            memcpy(udp_msg+ret,dns_ok,sizeof(dns_ok));
            dns_head->tag = sw16(0x8081);
            dns_head->numA = sw16(0x100);
            sendto(sock_fd,(uint8 *)udp_msg, ret + sizeof(dns_ok), 0, (struct sockaddr *)from,fromlen);
            //printf("ESP8266 UDP task > recv id:%x,tag:%x,%d \n",dns_head->ID,dns_head->tag,dns_head->numQ);
        }        
    }
}

void dnsserver_init(char *dns){
    char *sdot,*edot;
    char *c;
    mydns.name_len = strlen(dns);
    if(mydns.name_len < 5){
        return;
    }
    mydns.name_len ++;
    mydns.mylinks_dns = (char *)malloc(mydns.name_len);
    c = mydns.mylinks_dns;

    sdot = dns;
    edot = (char *)strchr(sdot,'.');
    if(NULL == edot){
        free(mydns.mylinks_dns);
        return;
    }
    *c = edot - sdot;
    memcpy(c + 1,sdot,*c);
    c += *c + 1;
    sdot = edot + 1;
    edot = (char *)strchr(sdot,'.');

    if(NULL == edot){
        free(mydns.mylinks_dns);
        return;
    }
    *c = edot - sdot;

    memcpy(c + 1,sdot,*c);
    c += *c + 1;
    sdot = edot + 1;
    edot = dns +  mydns.name_len - 1;
    *c = edot - sdot;
    memcpy(c+1,sdot,*c);   
    xTaskGenericCreate( createDnsServer, "dnsserver", TASK_HEAP_LEN, NULL, 6, NULL,  NULL ,  NULL  );
    return;

}





