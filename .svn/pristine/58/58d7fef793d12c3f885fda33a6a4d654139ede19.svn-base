#include <lynx_dev.h>
#include <event.h>
#include <common.h>
#include <serial.h>
#include <cfg_api_new.h>
#include "at_cmd.h"
#include "at_cmd_func.h"
#include "user_config.h"
#include "at.h"
#include "at_cmd_net.h"
#if defined(CONFIG_FREERTOS)
#include "FreeRTOSConfig.h"
#include "FreeRTOS.h"
#include "timers.h"
#include "task.h"
#include "semphr.h"
#include "queue.h"
SemaphoreHandle_t uart1_rx = NULL;
#endif
#define UART1 0
#define AT_CMD_NUM 40
#define AT_CMD_RX_BUFSIZE 64
#define AT_CMD_TRANS_PKG_SIZE 512


uint8_t specialAtState = true;
at_stateType  at_state = at_statIdle;
static uint8_t at_cmdLine[at_cmdLenMax];
extern uint8_t sendingID;
extern uint16_t at_sendLen;
extern sdk_param g_atParam;

extern void at_sockasendCheck(void *arg);
extern void at_sockbsendCheck(void *arg);
SemaphoreHandle_t sMutex = NULL; 

uint8_t at_dataLine[at_dataLenMax];
uint8_t *pDataLine = at_dataLine;
char uart1_rx_full = 0;
struct serial_buffer* ur1_rxbuf = NULL;
void (*enhance_scan_func)(void *list) = NULL;

extern u8	ur_irq[];
extern u32 urbase[];

extern char trans_mode;
extern int g_linkIdx;
extern int app_uart_isr(int chan);

char *at_err_str[] = {
    "operator",
    "parameter",
};

extern const char erasetoeol[];     //<ESC>[K<NUL>
extern const char eraseback[];      //erase backspace

atcmdt at_tb[AT_CMD_NUM]=
{
	//Basic command 6

#ifdef CONFIG_WLA
	//wifi interface 7
	{"wscan"    , at_wifi_scan     , "Scan ap, returns a list of found aps"},
	{"wphy"     , at_wifi_phy      , "Set or query phy mode, <mode>[1-7]"},
	{"wtxpwr"   , at_wifi_txpwr    , "Set or query tx power, <level>[0-12]"},
	{"wstaup"   , at_wifi_staup    , "Start station, <ssid><password>"},
	{"wstadn"   , at_wifi_stadn    , "Stop station"},
	{"wautoconn", at_wifi_autoconn , "Set or query auto connect, <en>"},
	{"wreconn"  , at_wifi_reconn   , "Reconnect to target ap, <en>[0-1]"},
	{"womcfgon" , at_wifi_omcfgon  , "Start omniconfig, [<sec>]"},
	{"womcfgoff", at_wifi_omcfgoff , "Stop omniconfig"},
	{"wapup"    , at_wifi_apup     , "Start softap, <ssid><pwd><ch>[<max conn>][<ssid hidden>]"},
	{"wapdn"    , at_wifi_apdn     , "Stop softap"},
	{"wlink"    , at_wifi_link     , "Link status, <idx>[0-1]"},
	{"wsta"     , at_wifi_sta      , "Show sta info"},
#if 0
	{"wps"      , at_wifi_wps      , "Set wps mode,<enable>"},
	{"mdns"     , at_wifi_mdns     , "Start or stop the mdns,<enable><hostname><server_name><port>"},
#endif
	{"wsleep"   , at_wifi_sleep    , "Set sleep mode,<mode>"},
#endif

#ifdef CONFIG_LWIP
	//Network interface
	{"dhcp"     , at_net_dhcp      , "Set or query dhcp mode, <mode>[0-3]"},
	{"dhcps"    , at_net_dhcps     , "Set or query the IP range of dhcps, <enable><lease time><start ip><end ip>"},
	{"ip"       , at_net_ip        , "Static ip, <idx>[,<ip>,<netmask>,<gw>]"},
	{"mac"      , at_net_mac       , "Set or query mac address, <idx><mac>"},
	{"ping"     , at_net_ping      , "Ping ip, <ipaddr>[,<len>,<count>,<timeout>]"},
	{"dns"      , at_net_dns       , "Set or query dns server, <svr idx><ip>"},
	{"host"     , at_net_host      , "Get host by name, <hostname>"},
	//Socket
	{"sadd"     , at_socket_add    , "Add conn, <conn idx>,<TCP/UDP>,<ip>,<dport>,[<TCP:keeplive/UDP:lport>]"},
	{"sdel"     , at_socket_del    , "Delete conn, <conn idx>"},
	{"ssend"    , at_socket_send   , "Send data, [<conn idx>,<length>]"},
	{"tmode"    , at_trans_mode    , "Enable trans mode,<enable>"},
	{"tcpserver", at_socket_TCPServer,"Start tcp server,<mode><port>"},
	{"savelink" , at_trans_savelink,"Save trans params,<mode><ip><port>[<type>][<time>]"},
	{"update"   , at_update        , "Update, <url>,<port>"},	
#endif
};






int uart_recv_sem_give(int ev_num)
{
#if defined(CONFIG_FREERTOS)
	struct serial_buffer *pbuf = ur1_rxbuf;
	uint16_t tail_len;
	int datalen, stat = 0;

	tail_len = serial_buffer_len(pbuf);

	datalen = serial_read_byte(1, UART1, pbuf->pin, tail_len, 0);//tail_len >= datalen
	serial_buffer_pin(pbuf,datalen);
	if(!pbuf->space){
#ifdef CONFIG_UR_FLOW_CONTROL		
		digital_write(CONFIG_UR_RTS, 1);//RTS deactive
#endif		
		uart1_rx_full = 1;
	}
	else{
		enable_irq(ur_irq[UART1]);
	}	
	xSemaphoreGive(uart1_rx);
#endif	
	return 0;
}

int uart_recv_sem_wait(void)
{
#if defined(CONFIG_FREERTOS)
	//if(xSemaphoreTake(uart1_rx, portMAX_DELAY) == pdTRUE)
	if(xSemaphoreTake(uart1_rx, 10) == pdTRUE)
	{

		return (ur1_rxbuf->pin != ur1_rxbuf->pout)?0:-1;
	}
	return -3;//unexpected err
#endif	
}


static uint8_t lower_to_upper(uint8_t data){
	if(!lowcase(data)){
		return data;	
	}
	return (data - 'a' + 'A');
}

void uart_cmd_proc(void){
	static uint8_t atHead[3];
	static uint8_t *pCmdLine;
	uint8_t temp;
	uint16_t send_len = 0;
	struct serial_buffer *pbuf = ur1_rxbuf;
	while(serial_buffer_empty(pbuf)){
		if(at_state < at_statIpSending){
			temp = serial_buffer_getchar(pbuf);
			if((temp != '\n') && (g_atParam.echoFlag)&&at_state != at_statIpSended){
				serial_write(0, &temp, 1); //display back
			}
		}
		switch(at_state){
			case at_statIdle: //serch "AT" head
			atHead[0] = atHead[1];
			atHead[1] = atHead[2];
			atHead[2] = lower_to_upper(temp);
			if(!memcmp(atHead,"+++",3)){
				memset(atHead,0,sizeof(atHead));
				at_backErrHead;
				uart0_sendStr("-1");
				at_backTail;
			}else if(!memcmp(atHead, "AT+", 3)){
				at_state = at_statRecving;
				pCmdLine = at_cmdLine;
				//atHead[2] = 0x00;
				memset(atHead,0,sizeof(atHead));
			}else if(temp == '\n'){
				at_backErrHead;
				uart0_sendStr("-1");
				at_backTail;
			}
			break;
			case at_statRecving: //push receive data to cmd line
			temp = lower_to_upper(temp);
			*pCmdLine = temp;
			pCmdLine++;
			if(temp == '='){
				at_state = at_statSetReving;
			}else if(temp == '\n'){
				*pCmdLine = '\0';
				at_state = at_statProcess;
				if(g_atParam.echoFlag){
					uart0_sendStr("\r\n");
				}
				//这里要执行任务了
				at_cmdProcess(at_cmdLine);
				if(specialAtState){
					at_state = at_statIdle;
				}
			}else if(pCmdLine >= (at_cmdLine + at_cmdLenMax)){
				at_state = at_statIdle;
			}				
			break;
			case at_statSetReving:
			*pCmdLine = temp;
			pCmdLine++;
			if(temp == '\n'){					
				*pCmdLine = '\0';
				at_state = at_statProcess;
				if(g_atParam.echoFlag){
					uart0_sendStr("\r\n");
				}
				//这里要执行任务了
				at_cmdProcess(at_cmdLine);
				if(specialAtState){
					at_state = at_statIdle;
				}
			}else if(pCmdLine >= (at_cmdLine + at_cmdLenMax)){
				at_state = at_statIdle;
			}
			break;
			case at_statIpSending:
			*pDataLine++ =  serial_buffer_getchar(pbuf);
			send_len = pDataLine - at_dataLine;
			if((send_len >= at_sendLen) || (send_len >= at_dataLenMax))
			{
				at_state = at_statIpSended;
				at_ipDataSending();
			}else if(!serial_buffer_empty(pbuf)){
				if(!sendingID){
					mylinks_add_timeout_fun(at_sockasendCheck,UART_TIME_SEND);
				}else{
					mylinks_add_timeout_fun(at_sockbsendCheck,UART_TIME_SEND);
				}
			}
			break;
			//透传模式
			case at_statIpTraning:
			//os_timer_disarm(&at_sendTimer[0]);
			*pDataLine++ =  serial_buffer_getchar(pbuf);
			send_len = pDataLine - at_dataLine;
			if( send_len >= at_dataLenMax){
				sendingID = 0;
				at_ipDataSending(at_dataLine);
			}else if(!serial_buffer_empty(pbuf)){
				if(3 == send_len && !memcmp(at_dataLine,"+++",3)){
					at_state = at_statIpTranout;
					mylinks_add_timeout_fun(at_sockasendSet, 3000);
					uart0_sendStr("a");
				}else{
					mylinks_add_timeout_fun(at_sockasendSet,UART_TIME_SEND);
				}
			}
			break;
			case at_statIpTranout:
			*pDataLine++ =  serial_buffer_getchar(pbuf);
			if(at_dataLine[3] == 'a' && !serial_buffer_empty(pbuf)){
				del_all_loop_time();
			//plink_cache_free(&plink[0]);
				//plink_cache_free(&plink[1]);
				at_state = at_statIdle;
				specialAtState = true;
				at_backOk;
			}else{
				at_state = at_statIpTraning;
			}
			pDataLine = at_dataLine;
			break;
			case at_statIpSended:
			break;
		}
	}
	return;
}

int at_cmd_start(void)
{
	for(;;){
		if(!uart_recv_sem_wait()){
			uart_cmd_proc();
		}
		uart_net_port();
		if(ldev->wmac.ps_uart != 2){
			ldev->wmac.ps_uart = 0;
		}
	}

exit:
	mico_rtos_delete_thread(NULL);
}

void at_cmd_thread(void *arg)
{
	at_cmd_start();
	vTaskDelete(NULL);
}

/*
void user_save_config(void){
	memset(&save_config,0,sizeof(struct user_save));
	return;
}
*/
void at_cmd_init(void)
{
	request_irq(ur_irq[UART1], &app_uart_isr, UART1);
	
#if defined(CONFIG_FREERTOS)
	sMutex = xSemaphoreCreateMutex();
	uart1_rx = xSemaphoreCreateBinary();
	xSemaphoreTake(uart1_rx, (TickType_t)10);

	ur1_rxbuf = serial_buf_init(AT_CMD_RX_BUFSIZE);
	if(ur1_rxbuf == NULL){
		serial_printf("ERR: UART1 Rx Buffer NULL\n");
		return;
	}

	EVENT_REGISTER((evt_func)uart_recv_sem_give, EVT_UART1_RX_NUM);


	//用户保存的数据初始化
	//user_save_config();
	if(g_atParam.tran_flag){
		at_setupCmdEntm(0);
	}
	xTaskCreate(at_cmd_thread, "atcmd", 4096, 0, 4, NULL);
#endif
	REG(urbase[UART1], URCS) |= URCS_RIE;
	return;	
}
